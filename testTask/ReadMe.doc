Добрый день! Мое решение.
Написано две программы, которые поддерживают Python2.7.x и 3.x:
1. task_linux.py (корректно работает только на Linux)
2. task_windows.py (корректно работает на Windows и на Linux)

При выполнении тестового задания хотелось показать, в том числе, навыки работы с ООП, поэтому первая реализация (task_linux.py) сделанная и протестированная в Linux содержит классы и методы. Использование классов обеспечило пространство имен внутри класса, что удобно, в том числе, для решения отдельных двух задач тестового задания.

При тестировании разработанной программы на Windows10 с Python3.5.4 для создания общего Lock потребовалось использовать Manager, который запускает отдельный процесс. При тестировании программы на Windows10 с Python2.7 возникла проблема связанная с невозможностью законсервировать (cPickle.PicklingError) метод класса  для передачи в map. Перепробовав большое количество предложенных в сети вариантов, понял что трачу слишком много времени и переписал программу без использования классов для Windows.

Для использования всех ядер процессора в обход GIL был выбран многопроцессный подход.  Функция map в применении с multiprocess позволили сократить количество кода и время вычисления.

Также были протестированы:
1) Была вероятность ускорения процесса за счет вызова функции записи файл меньшего количества раз, но с большим объемом. Для чего необходима реализации межпроцессного обмена данными, с этой целью был протестирован Queue, что привело к потерям времени (уменьшению эффективности программы). Я отказался от Queue.
2) Дополнительное разбиение каждого процесса (4 ядра = 4 процесса) по обработке архивов на потоки (theards) улучшения временных показателей не обеспечило, а код усложнило. От разбиения процессов на потоки отказался.

Результаты тестов:

1) task_linux.py
+ (CPU i3-5005U CPU @ 2.00GHz) «Linux Debian 8» с Python 2.7.9 и Python 3.4.2 были получены результаты соответственно: 1-я задача ~ 0.75 с, 2-я задача ~ 0.208 с и 1-я задача ~ 1.1 с, 2-я задача ~ 0.21 с.

2) task_windows.py
(CPU i5-4440, 3,10GHz) «Windows10» с Python 2.7.13 и Python 3.5.4 были получены результаты соответственно: 1-я задача ~ 0.51 с, 2-я задача ~ 0.63 с и
1-я задача ~ 0.94 с, 2-я задача ~ 0.75 с.

+ (CPU i3-5005U CPU @ 2.00GHz) «Linux Debian 8» с Python 2.7.9 и Python 3.4.2 были получены результаты соответственно: 1-я задача ~ 0.8 с, 2-я задача ~ 0.3 с и 1-я задача ~ 1.05 с, 2-я задача ~ 0.31 с.

Наиболее эффективным оказалась комбинация: «Linux Debian8», Python 2.7.9.

Решение этой задачи потребовало время на знакомство с модулями threading, multiprocessing, multiprocess, общее затраченное время (изучение методов библиотек, написание кода, тестирование и рефакторинг) я затратил примерно 23 часа. Сейчас аналогичную задачу решу значительно быстрее.

Выполнять тестовое задание было интересно. Отмечу также, что имею математический background и степень кандидата технических наук. Буду рад новым задачам и сотрудничеству с Вашей компанией.
